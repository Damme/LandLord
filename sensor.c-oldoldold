#include <stdio.h>
#include "common.h"
#include "sensor.h"
#include "powermgmt.h"
#include "common.h"
#include "timers.h"
#include "event_groups.h"
#include "global.h"

#include "LPC177x_8x.h"

#define BIT_ADC_DONE    ( 1 << 0 )
#define BIT_DIG_INT    ( 1 << 1 )

EventGroupHandle_t xSensorEventGroup;
xQueueHandle xDIGMsgQueue;
TimerHandle_t xADCTriggerTimer;



const uint16_t tempCalTbl[110] = {
    0xCF3, 0xCD6, 0xCB9, 0xC9B, 0xC7C, 0xC5A, 0xC3B, 0xC1B, 0xBFB, 0xBDB,
    0xBB5, 0xB93, 0xB72, 0xB50, 0xB2E, 0xB01, 0xADE, 0xABA, 0xA97, 0xA73,
    0xA46, 0xA23, 0x9FF, 0x9DB, 0x9B7, 0x984, 0x960, 0x93B, 0x917, 0x8F3,
    0x8C1, 0x89E, 0x87A, 0x857, 0x834, 0x800, 0x7DD, 0x7BA, 0x798, 0x776,
    0x743, 0x722, 0x701, 0x6E0, 0x6C0, 0x68E, 0x66F, 0x651, 0x633, 0x616,
    0x5E4, 0x5C7, 0x5AB, 0x590, 0x575, 0x545, 0x52B, 0x511, 0x4F8, 0x4DF,
    0x4B3, 0x49B, 0x484, 0x46E, 0x457, 0x42E, 0x419, 0x404, 0x3F0, 0x3DC,
    0x3B6, 0x3A3, 0x391, 0x37F, 0x36D, 0x34A, 0x339, 0x329, 0x319, 0x30A,
    0x2EA, 0x2DC, 0x2CD, 0x2C0, 0x2B2, 0x295, 0x288, 0x27C, 0x270, 0x264,
    0x249, 0x23E, 0x234, 0x229, 0x21F, 0x207, 0x1FD, 0x1F3, 0x1EA, 0x1E1,
    0x1CC, 0x1C4, 0x1BB, 0x1B3, 0x1AB, 0x198, 0x191, 0x18A, 0x183, 0x17C,
};

void vProcessDigitalInputs(void *pvParameter1, uint32_t ulParameter2) {
    /* ...Perform the processing here... */

    /*
    bool sensorFront()
    {
        return LPC_GPIO4->FIOPIN & PIN(29);
    }
    bool sensorRain()
    {
        return LPC_GPIO1->FIOPIN & PIN(29);
    }
    bool sensorCover()
    {
        return LPC_GPIO4->FIOPIN & PIN(28);
    }
    bool sensorLift()
    {
        return LPC_GPIO1->FIOPIN & PIN(16);
    }
    bool sensorCharger()
    {
        return LPC_GPIO1->FIOPIN & PIN(21);
    }
    uint8_t sensorDIP()
    {
        uint8_t val = 0;
        val = ((LPC_GPIO2->FIOPIN >> 7) & 1) | (((LPC_GPIO2->FIOPIN >> 3) & 1) << 1) | (((LPC_GPIO0->FIOPIN >> 1) & 1) << 2);
        return val;
    }
    uint8_t sensorWireR()
    {
        uint8_t val = 0;
        val = ((LPC_GPIO0->FIOPIN >> 9) & 1) | (((LPC_GPIO0->FIOPIN >> 10) & 1) << 1);
        return val;
    }
    uint8_t sensorWireL()
    {
        uint8_t val = 0;
        val = ((LPC_GPIO0->FIOPIN >> 7) & 1) | (((LPC_GPIO0->FIOPIN >> 8) & 1) << 1);
        return val;
    }
    */
}

int32_t convertAcc(uint16_t adc);
void printAcc(int32_t acc);

static volatile uint8_t ADC_Interrupt_Done_Flag;

#define ADC_DR_DONE(n)          (((n) >> 31))
#define ADC_DR_RESULT(n)        ((((n) >> 4) & 0xFFF))
#define channel                 (7)

/*
7 ~ 4
6 ~ 0-2
5 = 0
4 = 1-2
3 = 0
2 = 0
1 = 0
*/
void ADC_IRQHandler(void) {

    //portENTER_CRITICAL();
    NVIC_DisableIRQ(ADC_IRQn);
    //portEXIT_CRITICAL();
    LPC_ADC->INTEN &= ~((1 << ADC_Channel)); // channel

    ADC_Interrupt_Done_Flag = 1;
}

void OLD_ADC_IRQHandler(void) {
    NVIC_DisableIRQ(ADC_IRQn);
    LPC_ADC->INTEN &= ~(1 << 1);
// 	pADC->INTEN &= (~(1UL << channel));
//temp = pADC->DR[channel];
//if temp ((n) >> 31)) -> ok *data = (uint16_t) ADC_DR_RESULT(temp); -> ((((n) >> 4) & 0xFFF))
//	ADC_Interrupt_Done_Flag = 1;
//	App_print_ADC_value(dataADC);
//  NVIC_EnableIRQ(_LPC_ADC_IRQ);
//	pADC->INTEN |= (1UL << channel);

    //volatile uint32_t gdr;
    //portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

    //LPC_ADC->CR &= ~(1 << 16);
    /*LPC_ADC->CR |= (1 << 24);
    if (LPC_ADC->STAT & (1 << 0 )) ADC0++;
    if (LPC_ADC->STAT & (1 << 1 )) ADC1++;
    if (LPC_ADC->STAT & (1 << 2 )) ADC2++;
    if (LPC_ADC->STAT & (1 << 3 )) ADC3++;
    if (LPC_ADC->STAT & (1 << 4 )) ADC4++;
    if (LPC_ADC->STAT & (1 << 5 )) ADC5++;
    if (LPC_ADC->STAT & (1 << 6 )) ADC6++;
    if (LPC_ADC->STAT & (1 << 7 )) ADC7++;
*/  
    //TESTADC1++;
    /*if (TESTADC1 == 0) ADC0 = LPC_ADC->DR[0];
    if (TESTADC1 == 1) ADC1 = LPC_ADC->DR[1];
    if (TESTADC1 == 2) ADC2 = LPC_ADC->DR[2];
    if (TESTADC1 == 3) ADC3 = LPC_ADC->DR[3];
    if (TESTADC1 == 4) ADC4 = LPC_ADC->DR[4];
    if (TESTADC1 == 5) ADC5 = LPC_ADC->DR[5];
    if (TESTADC1 == 6) ADC6 = LPC_ADC->DR[6];
    if (TESTADC1 == 7) ADC7 = LPC_ADC->DR[7];*/
    /*if (LPC_ADC->STAT & (1 << 0 )) {
        ADC0 = LPC_ADC->DR[0];
        LPC_ADC->CR |= (1<<0);
    }
    if (LPC_ADC->STAT & (1 << 1 )) ADC1 = LPC_ADC->DR[1];
    if (LPC_ADC->STAT & (1 << 2 )) ADC2 = LPC_ADC->DR[2];
    if (LPC_ADC->STAT & (1 << 3 )) ADC3 = LPC_ADC->DR[3];
    if (LPC_ADC->STAT & (1 << 4 )) ADC4 = LPC_ADC->DR[4];
    if (LPC_ADC->STAT & (1 << 5 )) ADC5 = LPC_ADC->DR[5];
    if (LPC_ADC->STAT & (1 << 6 )) ADC6 = LPC_ADC->DR[6];*/
    //if (LPC_ADC->STAT & (1 << 7 )) ADC7 = LPC_ADC->DR[7];
    
    //TESTADC1 = (LPC_ADC->GDR);
  /*  ADC0 = LPC_ADC->DR[0];
    if (ADC0 >> 21) ADC0 = ADC0 >> 4 & 0xfff;
    ADC1 = LPC_ADC->DR[0];
    if (ADC1 >> 21) ADC1 = ADC1 >> 4 & 0xfff;
    ADC2 = LPC_ADC->DR[0];
    if (ADC2 >> 21) ADC2 = ADC2 >> 4 & 0xfff;
    ADC3 = LPC_ADC->DR[0];
    if (ADC3 >> 21) ADC3 = ADC3 >> 4 & 0xfff;
    ADC4 = LPC_ADC->DR[0];
    if (ADC4 >> 21) ADC4 = ADC4 >> 4 & 0xfff;
    ADC5 = LPC_ADC->DR[0];
    if (ADC5 >> 21) ADC5 = ADC5 >> 4 & 0xfff;
    ADC6 = LPC_ADC->DR[0];
    if (ADC6 >> 21) ADC6 = ADC6 >> 4 & 0xfff;
    ADC7 = LPC_ADC->DR[0];
    if (ADC7 >> 21) ADC7 = ADC7 >> 4 & 0xfff;
*/
    TESTADC2++;
    //LPC_ADC->STAT=65535;
    
    //LPC_ADC->CR |= (TESTADC1 << 0);
    //if (TESTADC1 == 7) TESTADC1=0;
    
    
    NVIC_ClearPendingIRQ(ADC_IRQn);
    NVIC_EnableIRQ(ADC_IRQn);
    LPC_ADC->INTEN |= (1 << 1);
    //LPC_ADC->INTEN = 1;
    //LPC_ADC->CR |=  (1 << 24);
    //xEventGroupSetBitsFromISR(xSensorEventGroup, BIT_ADC_DONE, &xHigherPriorityTaskWoken);
    //portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
    
    return;
}

typedef enum {
    DIG_POS_RAISING = 0,
    DIG_POS_FALLING,
    DIG_NEG_RAISING,
    DIG_NEG_FALLING,
} DIGEdge;

typedef enum {
    a = 0,
    b,
    c,
    d,
} DIGMux;

typedef struct {
    uint8_t id;
    uint32_t time;
    DIGMux mux;
    DIGEdge edge;
} MessageDIG;

void EINT3_IRQHandler(void) {
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    uint32_t counter = LPC_TIM2->TC; // Get µs counter

    NVIC_DisableIRQ(EINT3_IRQn);

    if (counter == 0) LPC_TIM2->TCR = 1; // start timer if 0

    xQueueSendFromISR(xDIGMsgQueue, &counter, &xHigherPriorityTaskWoken);

    // also need muxing p0.21 & p0.22 for distance and left/right -> outside int in task-sensor

    xEventGroupSetBitsFromISR(xSensorEventGroup, BIT_DIG_INT, &xHigherPriorityTaskWoken);

    // Important! If not cleared system freezes
    LPC_GPIOINT->IO0IntClr = PIN(7) | PIN(8) | PIN(9) | PIN(10);
    NVIC_ClearPendingIRQ(EINT3_IRQn);
    NVIC_EnableIRQ(EINT3_IRQn);

    portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
    return;
}

/*void vADCTriggerTimerCallback(TimerHandle_t xTimer)
{
    LPC_ADC->CR |= (1 << 16);
}*/

int32_t convert_temp(uint16_t raw_temp) {
    /* table holds 110 entries from -10°C to 100°C in full °C */
    int32_t fullDegree; /* full degrees */
    int32_t tenthDegree; /* 1/10th-degrees */
    for (fullDegree = 0; fullDegree < (sizeof(tempCalTbl) / sizeof(uint16_t)); fullDegree++) {
        if (tempCalTbl[fullDegree] < raw_temp) { /* just one above */
            if (fullDegree > 0) { /* valid range? */
                --fullDegree; /* one back */
                for (tenthDegree = 0; (tenthDegree < 10); tenthDegree++) { /* search along gradient */
                    if ((tempCalTbl[fullDegree] - (tempCalTbl[fullDegree] - tempCalTbl[fullDegree + 1]) * tenthDegree / 10) <= raw_temp)
                        break;
                }
            }
            goto done;
        }
        if (tempCalTbl[fullDegree] == raw_temp) {
            tenthDegree = 0;
            goto done;
        }
    }
done:
    return tenthDegree + 10 * (fullDegree - 10);
}

void task_Sensor(void *pvParameters) {
    /*
    xSensorEventGroup = xEventGroupCreate();

    xDIGMsgQueue = xQueueCreate(10, sizeof(MessageDIG));

    vTaskDelay(xDelay10);

    ADC0 = 0; // not in use??
    ADC1 = 0; // volt batt? ~ 3600
    ADC2 = 0; // tilt sideways
    ADC3 = 0; // tilt forward
    ADC4 = 0; // high = cold, low = warm?
    ADC5 = 0; // current spindle?
    ADC6 = 0; // current left?
    ADC7 = 0; // current right?

    // Configure ADC
    LPC_SC->PCONP |= PCONP_PCADC;               // power up ADC

    LPC_SC->PCLKSEL |= PCLK_ADC(CCLK_DIV8);    // set ADC CCLK/8 = 12.5M

    // Configure pins to ADC
    GPIO_PINFNC(ADC_AD0);
    GPIO_PINFNC(ADC_AD1);
    GPIO_PINFNC(ADC_AD2);
    GPIO_PINFNC(ADC_AD3);
    GPIO_PINFNC(ADC_AD4);
    GPIO_PINFNC(ADC_AD5);
    GPIO_PINFNC(ADC_AD6);
    GPIO_PINFNC(ADC_AD7);

    LPC_ADC->INTEN = (1 << 7);              // done flag

    LPC_ADC->CR = 255 | (1 << 21);

    // Enable burst mode / Disable power-down
    //      LPC_ADC->ADCR |= (1 << 16) | (1 << 21);

    portENTER_CRITICAL();
    NVIC_SetPriority(ADC_IRQn, 5);
    NVIC_EnableIRQ(ADC_IRQn);
    portEXIT_CRITICAL();

    // External INT - only wire sensor P0.7-P0.10
    LPC_GPIOINT->IO0IntEnR = (1 << 7) | (1 << 9);
    LPC_GPIOINT->IO0IntEnF = (1 << 8) | (1 << 10);
    LPC_GPIOINT->IO0IntClr = (1 << 7) | (1 << 8) | (1 << 9) | (1 << 10);

    // Configure Timer2 used for µs counter used in eint3 (wire)
//    LPC_SC->PCONP |= PCONP_PCTIM2;              // power up Timer (def on)
//    LPC_SC->PCLKSEL1 |= PCLK_TIMER2(CCLK_DIV1); // set Timer2 clock divider

    portENTER_CRITICAL();
    NVIC_SetPriority(EINT3_IRQn, 5);
    NVIC_EnableIRQ(EINT3_IRQn);
    portEXIT_CRITICAL();

    printf("Sensor interrupts enabled\r\n");

    // MUX switch - P0.4 + P0.5
#ifdef LPC175x_6x // DB275
    LPC_PINCON->PINSEL0 &= ~(3 << 8);
    LPC_PINCON->PINSEL0 &= ~(3 << 10);
    LPC_GPIO0->DIR |= (1 << 4) | (1 << 5);
    LPC_GPIO0->SET |= (1 << 4) | (1 << 5);   // MUX=3 - Bat. Temp.
#endif

    xADCTriggerTimer = xTimerCreate("ADCTriggerTimer", xDelay1000 * 5, pdTRUE, (void *) 0, vADCTriggerTimerCallback);
    if ((xADCTriggerTimer != NULL) && (xTimerStart(xADCTriggerTimer, 0) == pdPASS))
        printf("ADC Trigger Timer started\r\n");
    else
        printf("ADC Trigger Timer failed\r\n");
*/
    //
        // set ADC CCLK/8 = 12.5M
    
    uint32_t cr = 0;
    uint32_t fullAdcRate;
    uint8_t div;
    // #if defined(ADC_ACC_12BITS)
    fullAdcRate = 400000 * 31;
    div = ((PeripheralClock * 2 + fullAdcRate) / (fullAdcRate * 2)) - 1;

#define ADC_CR_CLKDIV(n)        ((((n) & 0xFF) << 8))
#define ADC_CR_EDGE             ((1UL << 27))

    LPC_SC->PCONP |= PCONP_PCADC;               // power up ADC
    //LPC_ADC->ADTRM = 0xF00;
    //ADC7 = ADC_CR_CLKDIV(div);
    //ADC6 = div;
    LPC_ADC->INTEN = 0;		/* Disable all interrupts */
    
    /*GPIO_PINFNC(ADC_AD0);
    GPIO_PINFNC(ADC_AD1);
    GPIO_PINFNC(ADC_AD2);
    GPIO_PINFNC(ADC_AD3);
    GPIO_PINFNC(ADC_AD4);
    GPIO_PINFNC(ADC_AD5);
    GPIO_PINFNC(ADC_AD6);
    GPIO_PINFNC(ADC_AD7);*/

/************************
 * When configured as an ADC input, the digital function of the pin must be disabled (see Section 8.4.1). 

P0[12] iocon 3 AD0[6] — A/D converter 0, input 6. 
P0[13] iocon 3 AD0[7] — A/D converter 0, input 7. 
P0[23] iocon 1 AD0[0] — A/D converter 0, input 0. 
P0[24] iocon 1 AD0[1] — A/D converter 0, input 1. 
P0[25] iocon 1 AD0[2] — A/D converter 0, input 2. 
P0[26] iocon 1 AD0[3] — A/D converter 0, input 3. 
P1[30] iocon 3 AD0[4] — A/D converter 0, input 4. 
P1[31] iocon 3 AD0[5] — A/D converter 0, input 5. 

*/
 /*   LPC_IOCON->P0_23 = 0;
    LPC_IOCON->P0_24 = 0;
    LPC_IOCON->P0_25 = 0;
    LPC_IOCON->P0_26 = 0;

    LPC_IOCON->P0_12 = 0;
    LPC_IOCON->P0_13 = 0;
    LPC_IOCON->P1_30 = 0;
    LPC_IOCON->P1_31 = 0;
    
    LPC_IOCON->P0_23 |= (1UL << 0) | (1UL << 7); 
    LPC_IOCON->P0_24 |= (1UL << 0) | (1UL << 7);
    LPC_IOCON->P0_25 |= (1UL << 0) | (1UL << 7);
    LPC_IOCON->P0_26 |= (1UL << 0) | (1UL << 7);

    LPC_IOCON->P0_12 |= (3UL << 0) | (1UL << 7);
    LPC_IOCON->P0_13 |= (3UL << 0) | (1UL << 7);
    LPC_IOCON->P1_30 |= (3UL << 0) | (1UL << 7);
    LPC_IOCON->P1_31 |= (3UL << 0) | (1UL << 7);
*/
    
    cr |= (1UL << 21);
    cr |= ((10 * 16) << 8); //clockdiv 8+9 stops, (burst 10 stops)
    //cr |= ADC_CR_CLKDIV(div);
    LPC_ADC->CR = cr;
    LPC_ADC->CR |= (1 << ADC_Channel); // Channel
    
    //TESTADC2=LPC_ADC->CR;

    portENTER_CRITICAL();
    NVIC_SetPriority(ADC_IRQn, 5);
    NVIC_EnableIRQ(ADC_IRQn);
    portEXIT_CRITICAL();
    LPC_ADC->INTEN |= (1 << ADC_Channel); // channel
    //LPC_ADC->CR |= ( 1 << 16); // Burst
    LPC_ADC->CR |= (1 << 24); // STARTNOW
    TESTADC3=LPC_ADC->CR;
    for (;;) {
        vTaskDelay(xDelay100);
        
        if ( ADC_Interrupt_Done_Flag ) {
            TESTADC1++;

            uint32_t ADCDR;
            ADCDR = LPC_ADC->DR[ADC_Channel];
    /*a1 = LPC_ADC->DR[1];
    a2 = LPC_ADC->DR[2];
    a3 = LPC_ADC->DR[3];
    a4 = LPC_ADC->DR[4];
    a5 = LPC_ADC->DR[5];
    a6 = LPC_ADC->DR[6];
    a7 = LPC_ADC->DR[7];*/
    /*ADC2 = (uint16_t) ADC_DR_RESULT(a4);
    ADC3 = (uint16_t) ADC_DR_RESULT(a4);*/
    //ADC1 = a4;
            if (ADC_DR_DONE(ADCDR)) { 
                ADC[ADC_Channel] = (uint16_t) ADC_DR_RESULT(ADCDR);
                TESTADC2++;
            }
            LPC_ADC->CR &= ~((1 << ADC_Channel));
        
            ADC_Channel++;
            if (ADC_Channel == 7) ADC_Channel = 0;
            
            LPC_ADC->CR |= (1 << ADC_Channel); // Channel
            
            
            NVIC_EnableIRQ(ADC_IRQn);
            LPC_ADC->INTEN |= (1 << ADC_Channel); // channel
            
            ADC_Interrupt_Done_Flag = 0;

            
                        //}
    //ADC[ADC_Channel] = (uint16_t) ADC_DR_RESULT(a0);
    /*if (ADC_DR_DONE(a1)) { ADC1 = (uint16_t) ADC_DR_RESULT(a1); }
    if (ADC_DR_DONE(a2)) { ADC2 = (uint16_t) ADC_DR_RESULT(a2); }
    if (ADC_DR_DONE(a3)) { ADC3 = (uint16_t) ADC_DR_RESULT(a3); }
    if (ADC_DR_DONE(a4)) { ADC4 = (uint16_t) ADC_DR_RESULT(a4); }
    if (ADC_DR_DONE(a5)) { ADC5 = (uint16_t) ADC_DR_RESULT(a5); }
    if (ADC_DR_DONE(a6)) { ADC6 = (uint16_t) ADC_DR_RESULT(a6); }
    if (ADC_DR_DONE(a7)) { ADC7 = (uint16_t) ADC_DR_RESULT(a7); }*/
    //ADC4 = (uint16_t) ADC_DR_RESULT(a4);
    //ADC5 = (uint16_t) ADC_DR_RESULT(a5);

    

    // LPC_ADC->INTEN |= (1 << ADC_Channel); // channel


            
            
            //LPC_ADC->CR &= ~ADC_CR_EDGE;
            
        }
    }

    //LPC_ADC->CR |= (9 << 8);
    //LPC_ADC->INTEN = 0;
/*
    GPIO_PINFNC(ADC_AD0);
    GPIO_PINFNC(ADC_AD1);
    GPIO_PINFNC(ADC_AD2);
    GPIO_PINFNC(ADC_AD3);
    GPIO_PINFNC(ADC_AD4);
    GPIO_PINFNC(ADC_AD5);
    GPIO_PINFNC(ADC_AD6);
    GPIO_PINFNC(ADC_AD7);
*/
/*
    LPC_IOCON->P0_23 |= (1 << 0); // ADC0
    LPC_IOCON->P0_24 |= (1 << 0); // ADC1
    LPC_IOCON->P0_25 |= (1 << 0); // ADC2
    LPC_IOCON->P0_26 |= (1 << 0); // ADC3
    LPC_IOCON->P1_30 |= (3 << 0); // ADC4
    LPC_IOCON->P1_31 |= (3 << 0); // ADC5
    LPC_IOCON->P0_12 |= (3 << 0); // ADC6
    LPC_IOCON->P0_13 |= (3 << 0); // ADC7
*/
/*
    LPC_IOCON->P0_12 &= ~(1 << 7);
    LPC_IOCON->P0_13 &= ~(1 << 7);
    LPC_IOCON->P0_23 &= ~(1 << 7);
    LPC_IOCON->P0_24 &= ~(1 << 7);
    LPC_IOCON->P0_25 &= ~(1 << 7);
    LPC_IOCON->P0_26 &= ~(1 << 7);
    LPC_IOCON->P1_30 &= ~(1 << 7);
    LPC_IOCON->P1_31 &= ~(1 << 7);
*/
    //LPC_ADC->CR |= (1 << 0) | (65 << 8) | (1 << 16) | (1 << 21);
    //LPC_SC->PCLKSEL |= PCLK_ADC(CCLK_DIV8);

    //LPC_ADC->INTEN |= (1 << 8);
//#define ADCR_CLKDIV8	8
//#define ADCR_CLKDIV9	9
//#define ADCR_CLKDIV10	10
    //LPC_ADC->CR &= 0xFFFEFF00;
    //LPC_ADC->CR |= (1 << 0) | (1 << 2);
    //LPC_ADC->CR |= (1 << 16);
    //LPC_ADC->CR |= (1<<1) | (1<<ADCR_CLKDIV8) | (1<<ADCR_CLKDIV10);
/*
    portENTER_CRITICAL();
    NVIC_SetPriority(ADC_IRQn, 5);
    NVIC_EnableIRQ(ADC_IRQn);
    portEXIT_CRITICAL();
    LPC_ADC->INTEN |= (1 << 1);
    */
    //LPC_ADC->CR |=  (1 << 21);
    //LPC_ADC->CR |=  (1 << 24);

    
/* Example
Init
    int adcChannel = 1
    LPC_ADC->CR |= ADC_CR_CH_SEL(adcChannel);     // select channel
    uint32_t adcReading = LPC_ADC->DR[adcChannel];// clear channel interrupt by reading it
    LPC_ADC->INTEN |= _BIT(adcChannel);           // enable interrupt for channel
    LPC_ADC->CR |= ADC_CR_START_NOW;                // start next conversion
void ADC_IRQHandler (void)
{
  // read channel causing interrupt, its value, its done flag and its overrun flag
  uint32_t globalDataRegister = LPC_ADC->GDR;

  if ( (globalDataRegister & 0x80000000) == 0 ) {
    uint32_t globalStatusRegister = LPC_ADC->STAT;
    ASSERT ( (globalDataRegister & 0x80000000) == 0x80000000 );
    return;
  }
  uint32_t adcChannel =  (globalDataRegister >> 24) & 0x7;

  // interrupt is not cleared unless data register is read ???
  uint32_t adcReading =  (globalDataRegister >> 4) & 0xFFF;
  // uint32_t adcReading =  (LPC_ADC->DR[adcChannel] >> 4) & 0xFFF;

  readingTable[adcChannel] = adcReading;

  LPC_ADC->CR |= ADC_CR_START_NOW;   // start next reading
}
*/
    
    
    for (;;) {

//        LPC_ADC->CR |= (255 << 0) | (16 << 8) | (1 << 16) | (1 << 21) | (1 << 24);
//            TESTADC1 = ADC_READ(5);
#if 0
        //xPowerMgmtMsg msg;
        //EventBits_t event = xEventGroupWaitBits(xSensorEventGroup, BIT_ADC_DONE | BIT_DIG_INT, pdTRUE, pdFALSE, xDelay100);
        if (event & BIT_ADC_DONE) {
            //uint32_t ulMuxState;
            //int32_t accx = convertAcc(ADC3);
            //int32_t accy = convertAcc(ADC2);
            //int32_t accz;

            //printf("\r\nADC: %04u %04u %04u %04u %04u %04u %04u %04u\r\n", ADC0, ADC1, ADC2, ADC3, ADC4, ADC5, ADC6, ADC7);

            //printf("Acc X (g): ");
            //printAcc(accx);
            //printf("Acc Y (g): ");
            //printAcc(accy);

#ifdef LPC175x_6x // DB275
            ulMuxState = (LPC_GPIO0->PIN & ((1 << 4) | (1 << 5))) >> 4;
            //printf("Mux: %01u\r\n", ulMuxState);
            switch (ulMuxState) {
                case 0:
                    accx = convertAcc(ADC4);
                    printf("Acc X2 (g): ");
                    printAcc(accx);
                    break;
                case 1:
                    accy = convertAcc(ADC4);
                    printf("Acc Y2 (g): ");
                    printAcc(accy);
                    break;
                case 2:
                    accz = convertAcc(ADC4);
                    //printf("Acc Z (g): ");
                    printAcc(accz);
                    break;
            }
            /* iterate over all mux choices */
            //LPC_GPIO0->FIOPIN = (LPC_GPIO0->FIOPIN & ~((1<<4) | (1<<5))) | (((ulMuxState + 1) % 4) << 4);
            /* just toggle between choices 'b10' (Z-axis) and 'b11' (Bat. Temp.) */

            LPC_GPIO0->PIN = (LPC_GPIO0->PIN & ~(1 << 4)) | (1 << 5) | (((ulMuxState + 1) % 2) << 4);
#endif

            //printf("Spindle I: %04u\r\n", ADC5);
            //printf("Right motor I: %04u\r\n", ADC6);
            //printf("Left motor I: %04u\r\n", ADC7);
#if 0
            msg.xType = MEASUREMENT_BATTERY;
            /* https://hackaday.io/project/6717-project-landlord/discussion-58892 */
            msg.measurement.lChargeCurrent = ADC0;
            msg.measurement.lBatteryVoltage = ADC1 * 1000 / 13018; /* 3770 = 28.9V, 28v = 3645, 27.5v = 3580, 27.36v = 3566, 26.74v = 3488 */
            if (ulMuxState == 3)
                msg.measurement.lBatteryTemperature = convert_temp(ADC4);
            else
                msg.measurement.lBatteryTemperature = INT32_MIN;
            xQueueSend(xPowerMgmtMsgQueue, &msg, (TickType_t)0);
#endif
        }
        if (event & BIT_DIG_INT) {
            //printf("DIG %ld\r\n", uxQueueMessagesWaiting(xDIGMsgQueue));
        }
#if LOWSTACKWARNING
        int stack = uxTaskGetStackHighWaterMark(NULL);
        if (stack < 50) printf("Task task_Sensor has %u words left in stack.\r\n", stack);
#endif
#endif
    }
}

int32_t convertAcc(uint16_t adc) {
    return ((int32_t)adc - 2060) * 1000 / (2720 - 2060);
}

void printAcc(int32_t acc) {
    if (acc >= 0) {
        printf(" %01ld.%03lu\r\n", acc / 1000, acc % 1000);
    } else {
        acc = ~acc;
        printf("-%01ld.%03lu\r\n", acc / 1000, acc % 1000);
    }
}
