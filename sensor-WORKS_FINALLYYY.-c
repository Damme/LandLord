
void task_Sensor(void *pvParameters) {
    
    uint32_t cr = 0;
    uint32_t fullAdcRate;
    uint8_t div;
    // #if defined(ADC_ACC_12BITS)
    fullAdcRate = 400000 * 31;
    div = ((PeripheralClock * 2 + fullAdcRate) / (fullAdcRate * 2)) - 1;

#define ADC_CR_CLKDIV(n)        ((((n) & 0xFF) << 8))
#define ADC_CR_EDGE             ((1UL << 27))

    LPC_IOCON->P0_12 = (1 << 8) | (3 << 0);
    LPC_IOCON->P0_13 = (1 << 8) | (3 << 0);
    LPC_IOCON->P0_23 = (1 << 8) | (1 << 0);
    LPC_IOCON->P0_24 = (1 << 8) | (1 << 0);
    LPC_IOCON->P0_25 = (1 << 8) | (1 << 0);
    LPC_IOCON->P0_26 = (1 << 8) | (1 << 0);
    LPC_IOCON->P1_30 = (1 << 8) | (3 << 0);
    LPC_IOCON->P1_31 = (1 << 8) | (3 << 0);

    LPC_ADC->CR = (4 << 8) | (1 << 21); //div 4 400000hz, enable ADC
    LPC_ADC->CR |= ( 0xff ); // enable all adc channels.
    LPC_ADC->CR |= (1UL<<16); // enable Burst mode
    
    uint32_t ADCDR;

    for (;;) {
        vTaskDelay(xDelay500);
        
        TESTADC1++;

#define ADC_DR_RESULT(n)        (((n>>4)&0xFFF))
        ADC[0]=ADC_DR_RESULT(LPC_ADC->DR[0]);
        ADC[1]=ADC_DR_RESULT(LPC_ADC->DR[1]);
        ADC[2]=ADC_DR_RESULT(LPC_ADC->DR[2]);
        ADC[3]=ADC_DR_RESULT(LPC_ADC->DR[3]);
        ADC[4]=ADC_DR_RESULT(LPC_ADC->DR[4]);
        ADC[5]=ADC_DR_RESULT(LPC_ADC->DR[5]);
        ADC[6]=ADC_DR_RESULT(LPC_ADC->DR[6]);
        ADC[7]=ADC_DR_RESULT(LPC_ADC->DR[7]);
        TESTADC2 = convert_temp(ADC[0]);
        TESTADC3 = LPC_ADC->CR;

    }
}
